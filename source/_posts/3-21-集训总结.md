---
title: 3-21 集训总结
date: 2019-03-21 17:16:00
tags: 比赛/考试
---

# exchange

> 有一个长度为 $n$ 的序列 $a$ ，$m$ 次询问，每次询问区间 $[l,r]$ 的价值，一个区间的价值定义为从 $[l,r]$ 中任意一个点出发到 $r$ ，初始值为 $0$，每次遇到一个比当前值更大的值就交换，所有起点的最大交换次数。
>
> $n,m\le 1.5\times10^6,a_i\le n$。

Expected Score：100 Points

Really Score：100 Points

考试的时候发现这题好像挺裸的，用之前的一个结论就可以直接做，然后就 A 了。

首先我们发现一个性质，从一个起点 $s$ 出发到一个点 $i$ 之前，当前值是区间 $[s,i]$ 的最大值。然后我们发现终点是固定的，所以可以询问离线下来按右端点分类。每次加入一个右端点找一下当前点对哪些点作为起点时有贡献，不难发现这些点是从左边第一个比当前点的大的点的下一个点到当前点一段连续的区间。我们用一个线段树维护终点为当前点时每个点到当前点这个区间的价值，那么就可以在 $O(n \log n)$ 的时间内解决这个问题了。

```cpp
#include <bits/stdc++.h>

#define x first
#define y second
#define mp make_pair
#define pb push_back
#define rl read<ll>()
#define ri read<int>()
#define inf (0x3f3f3f3f)
#define Set(a, b) memset(a, b, sizeof(a))
#define Cpy(a, b) memcpy(a, b, sizeof(a))
#define Rep(i, a) for (int i = 0; i < a; ++ i)
#define For(i, a, b) for (int i = a; i <= b; ++ i)
#define Forr(i, a, b) for (int i = a; i >= b; -- i)

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

template <class T> inline bool chkmax(T &_, T __) { return _ < __ ? _ = __, 1 : 0; }
template <class T> inline bool chkmin(T &_, T __) { return _ > __ ? _ = __, 1 : 0; }

template <class T> inline T read()
{
	T _ = 0, __ = getchar(), ___ = 1; 
	for (; !isdigit(__); __ = getchar()) if (__ == '-') ___ = -1;
	for (; isdigit(__); __ = getchar()) _ = _ * 10 + __ - 48;
	return _ * ___;
}

const int MAXN = 1.5e6 + 5;

int a[MAXN], ans[MAXN], n, m;
int Sta[MAXN], top;

vector<PII> Q[MAXN];

struct Segment_Tree
{
#define ls (bh << 1)
#define rs (ls | 1)
#define mid ((l + r) >> 1)
#define lson ls, l, mid
#define rson rs, mid + 1, r

	int S[MAXN << 2], tag[MAXN << 2];

	void pushup(int bh) { S[bh] = max(S[ls], S[rs]); }

	void modify(int bh, int z) { S[bh] += z, tag[bh] += z; }

	void pushdown(int bh) { if (tag[bh]) modify(ls, tag[bh]), modify(rs, tag[bh]), tag[bh] = 0; }

	void update(int bh, int l, int r, int x, int y)
	{
		if (x <= l && r <= y) return modify(bh, 1);
		pushdown(bh);
		if (x <= mid) update(lson, x, y);
		if (y > mid) update(rson, x, y);
		pushup(bh);
	}

	int query(int bh, int l, int r, int x, int y)
	{
		if (x <= l && r <= y) return S[bh];
		pushdown(bh);
		if (x > mid) return query(rson, x, y);
		if (y <= mid) return query(lson, x, y);
		return max(query(lson, x, y), query(rson, x, y));
	}

} T;

int main()
{
	n = ri, m = ri;
	For(i, 1, n) a[i] = ri;
	For(i, 1, m)
	{
		int x = ri, y = ri;
		Q[y].pb(mp(i, x));
	}
	For(r, 1, n)
	{
		while(top && a[Sta[top]] < a[r]) -- top;
		T.update(1, 1, n, Sta[top] + 1, r);
		for (auto v : Q[r]) ans[v.x] = T.query(1, 1, n, v.y, r);
		Sta[++ top] = r; 
	}
	For(i, 1, m) printf("%d\n", ans[i]);
	return 0;
}
```

# tree

> 有一棵树，你每次可以询问两个点和一个集合 $S$ ，交互库会返回两点间路径中的点构成的集合与 $S$ 集合交集的大小，你需要在 $t$ 次询问内确定这棵树。
>
> $n \le 1000,t=1.2\times10^4$。

Expected Score：100

Really Score：100

考试的时候发现这个东西每个点父亲集合是可以确定的，那么直接二分是这个集合的哪些点就可以在 $n \log n$ 次询问内解决这个问题了。

首先考虑最裸的暴力，枚举任意两个点考虑他们是否相邻。这样子瓶颈在确定了任意两个点的距离，实际上我们可以枚举一个点作为根，就可以通过询问全集知道每个点的深度，那么把点按深度分类，深度为 $x$ 的点的父亲深度一定为 $x - 1$ ，那么我们直接把深度为 $x - 1$ 的点当做一个区间，二分出父亲在区间哪个位置即可。

```cpp
#include "tree.h"
#include <bits/stdc++.h>

#define x first
#define y second
#define mp make_pair
#define pb push_back
#define rl read<ll>()
#define ri read<int>()
#define inf (0x3f3f3f3f)
#define Set(a, b) memset(a, b, sizeof(a))
#define Cpy(a, b) memcpy(a, b, sizeof(a))
#define Rep(i, a) for (int i = 0; i < a; ++ i)
#define For(i, a, b) for (int i = a; i <= b; ++ i)
#define Forr(i, a, b) for (int i = a; i >= b; -- i)

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

template <class T> bool chkmax(T &_, T __) { return _ < __ ? _ = __, 1 : 0; }
template <class T> bool chkmin(T &_, T __) { return _ > __ ? _ = __, 1 : 0; }

const int MAXN = 1e3 + 5;

bool S[MAXN];

int dis[MAXN], mx;

vector<int> G[MAXN];

void solve(int n, int t)
{
	For(i, 1, n) S[i] = 1; 
	For(i, 2, n)
	{
		G[dis[i] = query(1, i, S) - 1].pb(i);
		chkmax(mx, dis[i]);
		if (dis[i] == 1) submit(1, i);
	}
	For(i, 1, n) S[i] = 0;
	For(i, 2, mx) for (auto v : G[i])
	{
		int l = 0, r = G[i - 1].size() - 1, pos;
		while (l <= r)
		{
			int mid = (l + r) >> 1, flag;
			For(j, l, mid) S[G[i - 1][j]] = 1; 
			flag = query(1, v, S);
			For(j, l, mid) S[G[i - 1][j]] = 0;
			if (flag) pos = mid, r = mid - 1;
			else l = mid + 1; 
		}
		submit(v, G[i - 1][pos]);
	}
}
```

# hanoi

> 给你三个栈，第一个栈里有一个长为 $n$ 的排列，你需要把这个排列移动到第三个栈中并按顺序排列。每次可以把第一个栈前 $x（x\le a）$ 个元素移动到第二个栈，或者把第二个栈前 $x（x \le b）$ 个元素移动到第三个栈，你需要求出一种合法的方案或者判断无解。
>
> $n\le 1200,1\le a,b\le n$。

考试的时候看了四个小时左右，推出来的东西都没有转化成能拿分的东西，最后只有搜索的暴力分。

这个题太毒了不想改。