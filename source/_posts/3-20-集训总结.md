---
title: 3-20 集训总结
date: 2019-03-20 23:44:02
tags: 比赛/考试
---

# duliu

> 给你一个长为 $n$ 的序列 $d$ ， $q$ 次询问。一个区间 $[l,r]$ 的价值为$val(l,r)=(\sum\limits_{i = l}^rd_i)\times(r-l+1)$，每次询问一个区间价值大于等于 $x$ 的子区间中，子区间最大的 $d$ 最小是多少。
>
> $n,q\le3\times10^5,d_i\le 10^7,1\le l_i \le r_i \le n,x_i \le 10^{18}$。

Expected Score：8

Really Score：23

莫名 $O(n^2\log n)$ 过了 $n \le 5000$ ，考试的时候一直刚根号做法没有刚出来，最后只有暴力分。

实际上这道题对于一个询问 $(L,R,x)$ ，我们需要的区间$[a,b]$只需要满足下列条件中的一个：

- 1. $a=L$ 或 $b = R$ 。

- 2. $d_b,d_a>\max\limits_{j = a + 1}^b d_j$。

第一类区间我们只需要最小化区间长度，例如 $a = L$ 我们只需要找到一个最大的 $p$ 满足 $val(L,p)\ge x$，只需要二分 $p$ 的位置即可，$b = R$ 时同理。

第二类区间实际上总数只有 $n$ 个，我们可以用单调栈来找到他们，然后我们把这 $n$ 个区间价值和询问的 $x$ 一起从大到小排序，用一个线段树维护每个点作为左端点时区间最大的 $d$ 最小是多少，假如有跨过右端点的区间那第一类区间就是这种区间的一个子区间，不会影响答案，因为从大到小排序所以区间价值的限制肯定满足。

总复杂度 $O((n+m)\log{n + m})$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 3e5 + 5;

int n, q, a[MAXN];

ll S[MAXN];

ll val(int l, int r) { return (S[r] - S[l - 1]) * (r - l + 1) * 2; }

int st[MAXN][19];

int lg2(int x) { return 31 - __builtin_clz(x); }

int qmax(int l, int r)
{
	int len = lg2(r - l + 1);
	return max(st[l][len], st[r - (1 << len) + 1][len]);
}

void ST_Init()
{
	for (int j = 0; j < 19; ++ j) 
		for (int i = 1; i + (1 << j) - 1 <= n; ++ i)
			st[i][j] = j ? max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]) : a[i];
}

int ans[MAXN], L[MAXN], R[MAXN];

struct node { int id, x, y, mxl; ll z; } Q[MAXN << 1];

bool cmp(node A, node B) { return A.z == B.z ? A.id < B.id : A.z > B.z; }

struct Segment_Tree
{
#define ls (bh << 1)
#define rs (ls | 1)
#define mid ((l + r) >> 1)
#define lson ls, l, mid
#define rson rs, mid + 1, r

	int S[MAXN << 2];

	Segment_Tree() { memset(S, 0x3f, sizeof(S)); }

	void update(int bh, int l, int r, int x, int z)
	{
		if (l == r) return S[bh] = min(S[bh], z), void();
		if (x <= mid) update(lson, x, z);
		else update(rson, x, z);
		S[bh] = min(S[ls], S[rs]);
	}

	int query(int bh, int l, int r, int x, int y)
	{
		if (x > y) return INT_MAX;
		if (x <= l && r <= y) return S[bh];
		if (x > mid) return query(rson, x, y);
		if (y <= mid) return query(lson, x, y);
		return min(query(lson, x, y), query(rson, x, y));
	}
#undef mid

} T;

int main()
{
	memset(ans, 0x3f, sizeof(ans));
	scanf("%d%d", &n, &q);
	for (int i = 1; i <= n; ++ i)
	{
		scanf("%d", &a[i]); 
		S[i] = S[i - 1] + a[i];
	}
	ST_Init();
	for (int i = 1; i <= q; ++ i)
	{
		scanf("%d%d%lld", &Q[i].x, &Q[i].y, &Q[i].z);
		if (val(Q[i].x, Q[i].y) < Q[i].z) ans[i] = -1, Q[i].id = i;
		else
		{
			static int l, r, mid, pos;
			for (l = Q[i].x, r = Q[i].y; l <= r; )
			{
				mid = (l + r) >> 1;
				if (val(Q[i].x, mid) >= Q[i].z)
					pos = mid, r = mid - 1;
				else l = mid + 1; 
			}
			ans[i] = min(ans[i], qmax(Q[i].x, pos));
			for (l = Q[i].x, r = Q[i].y; l <= r; )
			{
				mid = (l + r) >> 1;
				if (val(mid, Q[i].y) >= Q[i].z)
					pos = mid, l = mid + 1; 
				else r = mid - 1;
			}
			ans[i] = min(ans[i], qmax(pos, Q[i].y));
			Q[i].id = i, Q[i].mxl = pos - 1;
		}
	}
	static int Sta[MAXN], top;
	a[Sta[top = 0] = 0] = 1e9;
	for (int i = 1; i <= n; Sta[++ top] = i ++)
	{
		while (top && a[Sta[top]] <= a[i]) -- top;
		L[i] = Sta[top] + 1;
	}
	a[Sta[top = 0] = n + 1] = 1e9;
	for (int i = n; i >= 1; Sta[++ top] = i --)
	{
		while (top && a[Sta[top]] <= a[i]) -- top;
		R[i] = Sta[top] - 1;
	}
	for (int i = 1; i <= n; ++ i)
	{
		Q[++ q].z = val(L[i], R[i]);
		Q[q].x = L[i], Q[q].mxl = R[i], Q[q].y = a[i];
	}
	sort(Q + 1, Q + q + 1, cmp);
	for (int i = 1; i <= q; ++ i)
	{
		if (Q[i].id) ans[Q[i].id] = min(ans[Q[i].id], T.query(1, 1, n, Q[i].x, Q[i].mxl));
		else T.update(1, 1, n, Q[i].x, Q[i].y);
	}
	for (int i = 1; i <= q - n; ++ i)
		printf("%d\n", ans[i]);

	return 0;
}
```



# gre

> 求一个长度为 $n$ ，出现了 $k$ 种字符，字典序最小的字符串，满足串的每个前缀与后缀出现的字符两两不同。
>
> $n \le 10^5,k \le 26$。

Expected Score：58

Really Score：14

考试的时候判无解的一种情况输出了小写，直接把 $n \le 20$ 的 $44$ 分全丢了。

先写一发暴力，很容易发现字符串足够长时就是在前面无限加 $a$ ，那么我们只要找到刚好有解时的字符串的规律即可：

- 1. $n=1,k=1,ans=a$。

  2. $n = 5,k = 2,ans=aabaa$。
  3. $n = 12,k = 3,ans=aababacbabaa$

设 $B=ba,D=dcba$ ，按这种方法类似定义，那么上面的东西变成了：

- 1. $n = 1,k = 1,ans=A$ 。
  2. $n = 5,k = 2,ans=AABA$ 。
  3. $n  = 12,k = 3, ans = AABBCBA$。

~~大胆猜想~~可以发现， $k = 4$ 的答案是 $AABBCCDCBA$。

答案的规律已经很显然了，那么直接算就好了，复杂度 $O(n + k)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
	int T, n, k;
	for (scanf("%d", &T); T -- ; )
	{
		scanf("%d%d", &n, &k);
		int s = k * (k - 1) / 2 * 3 + k;
		if (n < s) puts("CiYe");
		else
		{
			for (int i = 1; i <= n - s; ++ i)
				putchar('a');
			for (int i = 1; i < k; ++ i)
				for (int qwq = 2; qwq -- ; ) 
					for (int j = i - 1; ~j; -- j) 
						putchar('a' + j);
			for (int i = k; i >= 1; -- i) 
				for (int j = i - 1; ~j; -- j) 
					putchar('a' + j);
			putchar('\n');
		}
	}
	return 0;
}
```

# tetris

[题意点我（其实这个链接就是游戏地址）](https://yycjm.github.io/Pages/russian.html)

Expected Score：15

Really Score：15

考试的时候根本玩不动，就随了一下拿了大概 $10\%$ 的分数。

太难改了不想改。