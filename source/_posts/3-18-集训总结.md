---
title: 3-18 集训总结
date: 2019-03-18 13:59:24
tags: 比赛/考试
---

# gra

> 给你 $n$ 个点，第 $i$ 个点的坐标为 $(\cos \frac{2i\pi}{n},\sin \frac{2i\pi}{n})$ ，这 $n$ 个点形成了一个无向完全图，每条边是黑色或者白色，你可以向交互库询问两个点之间的边的颜色，求一个颜色相同的边构成的最小生成树满足不存在两条边不在端点处相交。
>
> $2\le n \le 1000$，设 $t$ 为询问次数，得分为该测试点总分的$\lfloor \max(0.3,\min(1,\frac{12\max(n,5)-t}{10n})) \rfloor$。

Expected Score：0 Points

Really Score：0 Points

考试的时候暴力没有调出来，会出现图不联通的情况。

实际上我们按 $1,2,3,...,n$ 顺次连接显然是合法的，如果有一个点相邻的边颜色不同，就删除它并把和它相连的两个点连接，最后会被删到剩一个颜色相同的环，那么环上的边删一条，被删除的点把删除前和环的颜色边相同的边加入即可，询问次数 $2n$ 次。

```cpp
#include "gra.hpp"
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 1000 + 5;

set <int> S;

int a[MAXN][MAXN], L[MAXN], R[MAXN], ch[MAXN][2];

int color(int x, int y)
{
	if (a[x][y] == -1) a[x][y] = a[y][x] = query(x, y);
	return a[x][y];
}

bool update(int x)
{
	int l = color(L[x], x), r = color(R[x], x);
	ch[x][l] = L[x], ch[x][r] = R[x];
	return l != r;
}

void tree(int n)
{
	memset(a, -1, sizeof(a));
	for (int i = 1; i <= n; ++ i) 
		L[i] = i - 1, R[i] = i + 1;
	L[1] = n, R[n] = 1; 
	for (int i = 1; i <= n; ++ i)
		S.insert(i);
	while (true)
	{
		int flag = 0;
		for (auto v : S) if (update(v))
		{
			S.erase(flag = v);
			int l = L[v], r = R[v];
			R[l] = r, L[r] = l;
			break;
		}
		if (!flag) break;
	}
	int u = *S.begin(), v = R[u], fin = color(u, v);
	for (int i = v; i != u; i = R[i])
		report(L[i], i);
	for (int i = 1; i <= n; ++ i) 
		if (S.find(i) == S.end())
			report(ch[i][fin], i);
}
```



# edg

> 给你一个联通的偶正则图，找到原图边集的一个子集的使得原图变成二正则图。
>
> $n,m\le10^5$。

Expected Score：0 Points

Really Score：0 Points

考试的时候写了 $O(n!)$ 的暴力，没有调出来。

因为每个点度数都是偶数我们可以找到一条欧拉回路，我们把边按欧拉回路上的方向定向，那么每个点的入度和出度都是 $k$ ，我们要让每个点入度出度都变成 $1$ ，那么我们考虑把每个点拆成入点和出点，如果存在一条边 $(a,b)$，那么 $a$ 的出点向 $b$ 的入点连边，那么这样原图会形成一个二分图，并且二分图上的一个完美匹配就对应着一种合法方案。用 Dinic 算法可以在 $O(m \sqrt m)$ 的时间内解决这个问题。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 2e5 + 5;

struct Edge { int x, y; } E[MAXN];

int n, m, S, T;

namespace MF
{
	const int MAXM = 2e6 + 5;

	int to[MAXM], head[MAXN], nxt[MAXM], w[MAXM], e = 1; 

	void add(int x, int y, int z) 
	{ 
		to[++ e] = y, nxt[e] = head[x], head[x] = e, w[e] = z; 
		if (z) add(y, x, 0);
	}

	static int dis[MAXM];

	bool BFS()
	{
		queue<int> q; 
		for (int i = 1; i <= T; ++ i) dis[i] = 0;
		dis[S] = 1, q.push(S);
		for (; !q.empty(); q.pop())
		{
			int u = q.front();
			for (int i = head[u]; i; i = nxt[i])
				if (w[i] && !dis[to[i]])
				{
					q.push(to[i]);
					dis[to[i]] = dis[u] + 1; 
				}
		}
		return dis[T];
	}

	int dfs(int u, int flow)
	{
		if (u == T || !flow) return flow;
		int used = 0;
		for (int &i = head[u]; i; i = nxt[i])
			if (w[i] && dis[to[i]] == dis[u] + 1)
			{
				int d = dfs(to[i], min(flow, w[i]));
				w[i] -= d, flow -= d; 
				w[i ^ 1] += d, used += d;
				if (!flow) break;
			}
		return used;
	}

	void dinic()
	{
		static int cur[MAXM];
		for (int i = 1; i <= T; ++ i) 
			cur[i] = head[i];
		int res = 0;
		while (BFS())
		{
			res += dfs(S, 1e9);
			for (int i = 1; i <= T; ++ i)
				head[i] = cur[i];
		}
		unordered_map<int, bool> vis[MAXN];
		for (int u = 1; u <= n; ++ u)
			for (int i = head[u]; i; i = nxt[i])
				if (to[i] <= n * 2 && !w[i])
					vis[u][to[i] - n] = 1;
		for (int i = 1; i <= m; ++ i) 
			if (!vis[E[i].x][E[i].y] && !vis[E[i].y][E[i].x])
				printf("%d %d\n", E[i].x, E[i].y);
	}

}

int to[MAXN], head[MAXN], nxt[MAXN], vis[MAXN], e = 1;

void add(int x, int y) { to[++ e] = y, nxt[e] = head[x], head[x] = e; }

void dfs(int u)
{
	for (int &i = head[u]; i; i = nxt[i])
	{
		if (vis[i]) continue;
		vis[i] = vis[i ^ 1] = 1;
		MF::add(u, to[i] + n, 1);
		dfs(to[i]);
	}
}

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; ++ i)
	{
		scanf("%d%d", &E[i].x, &E[i].y);
		add(E[i].x, E[i].y), add(E[i].y, E[i].x);
	}
	dfs(1), T = (S = n << 1 | 1) + 1; 
	for (int i = 1; i <= n; ++ i)
		MF::add(S, i, 1), MF::add(i + n, T, 1);
	printf("%d\n", m - n);
	return MF::dinic(), 0;
}
```

# mie

> [题意点我（其实这个链接就是游戏地址。）](https://kbhgames.com/game/pixoji)

Expected Score：40 Points

Really Score：40 Points

考试的时候就只玩了 $4$ 个点。

太毒瘤了不想改。