---
title: 3.17 集训总结
date: 2019-03-17 22:06:09
tags: 比赛/考试
mathjax: true
---

# str

> 定义 $f(S)$ 为一个字符串的最小表示，例如 $f(\rm ACGAT)=abcad$ ，给你一个字符串求它有多少个子串满足其 $f$ 各不相同．
>
> $n \le 10^5​$．

Expected Score：30 Points

Really Score：10 Points

考试的时候没有仔细思考这道题，一开始只是觉得可以做 $O(n^2)​$ 的暴力就把这题扔了，最后一个小时才写的这道题发现暴力似乎也有点麻烦，最后折腾了 20 分钟还是码了一个哈希判重的做法，但是自己的哈希写的太简陋了就 Subtask2 被卡掉了．

部分分实际上对正解提示很大，字符集只有 2 的情况可以考虑把字符串和它取反后的串扔进 SAM 里求出本质不同子串个数除以 2 就是答案．我们考虑把这个方法推广一下，我们先把所有串 $4!$ 种排列扔进一个广义 SAM 里，我们考虑统计这个 SAM 本质不同的子串数，发现出现了 $x$ 种字符的子串会被算 $\binom 4 x\times x!$ 次，所以我们可以统计出现了几种字符的子串的出现次数．记一个 $pos(i,j)$ 表示满足区间 $[pos(i, j),i]$ 中出现了$j$种字符的最大值，这个东西显然可以二分求，那么我们直接遍历 SAM 就可以统计出现了几种字符串的出现次数了，只需要简单的区间取交集就好了，复杂度$O(4!\times n)$．

```cpp
#include <bits/stdc++.h>

#define Cpy(a, b) memcpy(a, b, sizeof(a))
#define For(i, a, b) for (int i = a; i <= b; ++ i) 

using namespace std;

const int MAXN = 1e5 + 5;
const int MAXM = 5e6 + 5;

int pre[MAXN][4], pos[MAXN][5];

struct Suffix_Automaton
{
	int len[MAXM], trans[MAXM][4], link[MAXM], ed[MAXM], lst, cnt;

	Suffix_Automaton() { lst = cnt = 1; }

	void extend(int to, int id)
	{
		int p = lst, now = lst = ++ cnt;
		len[now] = len[p] + 1, ed[now] = id;
		for (; p && !trans[p][to]; p = link[p]) trans[p][to] = now;
		if (!p) link[now] = 1; 
		else
		{
			int x = trans[p][to], nx;
			if (len[x] == len[p] + 1) link[now] = x; 
			else
			{
				len[nx = ++ cnt] = len[p] + 1, ed[nx] = ed[x];
				link[nx] = link[x], Cpy(trans[nx], trans[x]);
				for (; p && trans[p][to] == x; p = link[p]) trans[p][to] = nx;
				link[now] = link[x] = nx;
			}
		}
	}

	void Solve()
	{
		long long ans[4] = {0}, sum = 0;
		For(i, 2, cnt) For(j, 0, 3)1
		{
			static int l1, l2, r1, r2, res;
			l1 = ed[i] - len[i] + 1, r1 = ed[i] - len[link[i]];
			l2 = pos[ed[i]][j + 1] + 1, r2 = pos[ed[i]][j];
			res = min(r1, r2) - max(l1, l2) + 1;
			if (res >= 0) ans[j] += res;
		}
		int c[4] = {4, 6, 4, 1}, fac = 1;
		For(j, 0, 3) sum += ans[j] / (c[j] * (fac *= j + 1));
		cout << sum << endl;
	}

} SAM;

int s[MAXN], p[4], n;

int query(int l, int r)
{1
	int res = 0;
	For(j, 0, 3) if (pre[r][j] - pre[l - 1][j]) ++ res;
	return res;
}

int main()
{
	freopen("str.in", "r", stdin);
	freopen("str.out", "w", stdout);
	static char s0[MAXN];
	scanf("%s", s0 + 1), n = strlen(s0 + 1);
	For(i, 1, n) 
	{
		if (s0[i] == 'A') s[i] = 0;
		if (s0[i] == 'C') s[i] = 1;
		if (s0[i] == 'G') s[i] = 2;
		if (s0[i] == 'T') s[i] = 3;
	}
	For(i, 0, 3) p[i] = i;
	for (; ; SAM.lst = 1) 
	{
		For(i, 1, n) SAM.extend(p[s[i]], i);
		if (!next_permutation(p, p + 4)) break;
	}
	For(i, 1, n) 
	{
		Cpy(pre[i], pre[i - 1]), ++ pre[i][s[i]];
		For(j, 0, min(i - 1, 3)) 
		{
			int l = 1, r = i, res = 0;
			while (l <= r)
			{
				int mid = (l + r) >> 1;
				if (query(mid, i) >= j + 1)
					res = mid, l = mid + 1; 
				else r = mid - 1;
			}
			pos[i][j] = res;
		}
	}
	SAM.Solve();
	return 0;
}
```

# wlk

> 给你一个有向图，每条边上有一个字母，给你两个字符串 A, B，问从 $1​$ 号点出发每次随机选择当前点的一条出边，走到经过的字符存在一个子串是 A 或存在一个子序列是 B 时的期望步数．
>
> $n \le 20,|A|\le10,|B| \le 50​$．

Expected Score：50 Points

Really Score：50 Points

考试的时候写暴力花了很多时间，本来想了可以先解出大的 DP 值再来解小的，但是以为转移跟两维都有关系没有冷静下来思考，所以就只拿了暴力分．

按期望 DP 的套路，设 $f(i,j,k)$ 表示在 $i$ 号点已经匹配了字符串 A 的前 $j$ 位，字符串 B 的前 $k$ 位时停下来的期望步数，每个状态对于每条边都能转移到一个固定的状态，预处理一下高斯消元就可以$O((n|A||B|)^3)$，实际上消元的时候 $k$ 从大到小枚举就可以做到 $O(|B|(n|A|)^3)$了．

```cpp
#include <bits/stdc++.h>

#define x first
#define y second
#define mp make_pair
#define pb push_back
#define rl read<ll>()
#define ri read<int>()
#define inf (0x3f3f3f3f)
#define Set(a, b) memset(a, b, sizeof(a))
#define Cpy(a, b) memcpy(a, b, sizeof(a))
#define For(i, a, b) for (int i = a; i <= b; ++ i)
#define Forr(i, a, b) for (int i = a; i >= b; -- i)

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

template <class T> inline bool chkmax(T &_, T __) { return _ < __ ? _ = __, 1 : 0; }
template <class T> inline bool chkmin(T &_, T __) { return _ > __ ? _ = __, 1 : 0; }

template <class T> inline T read() 
{
	T _ = 0, __ = getchar(), ___ = 1; 
	for (; !isdigit(__); __ = getchar()) if (__ == '-') ___ = -1;
	for (; isdigit(__); __ = getchar()) _ = (_ << 3) + (_ << 1) + (__ ^ 48);
	return _ * ___;
}

const int MAXN = 20;
const int MAXA = 10;
const int MAXB = 50;
const int Mod = 998244353;

int qpow(int a, int x)
{
	int ret = 1; 
	while (x)
	{
		if (x & 1) ret = ret * (ll)a % Mod;
		x >>= 1, a = a * (ll)a % Mod;
	}
	return ret;
}

int lena, lenb;

vector<int> G[MAXN + 5][26];

char a[MAXA + 5], b[MAXB + 5];

int nxt[MAXA + 5][26];
int suf[MAXB + 5][26];
int de[MAXN + 5];

int A[MAXN * MAXA + 5][MAXN * MAXA + 5];
int vis[MAXN * MAXA + 5];
int dp[MAXN + 5][MAXA + 5][MAXB + 5];
int id[MAXN + 5][MAXA + 5];

void Gauss(int n)
{
	For(i, 1, n) For(j, i + 1, n) 
	{
		ll d = qpow(A[i][i], Mod - 2) * (ll)A[j][i] % Mod % Mod;
		For(k, i, n + 1) (A[j][k] -= A[i][k] * d % Mod) %= Mod;
	}
	Forr(i, n, 1) 
	{
		vis[i] = A[i][n + 1];
		For(j, i + 1, n) (vis[i] += (ll)vis[j] * A[i][j] % Mod) %= Mod, A[i][j] = 0;
		vis[i] = (ll)vis[i] * qpow(-A[i][i], Mod - 2) % Mod;
		A[i][i] = A[i][n + 1] = 0;
	}
}

int main()
{
	int n = ri, m = ri, x, y;
	For(i, 1, m)
	{
		x = ri, y = ri, scanf("%s", a + 1);
		G[x][a[1] - 'a'].pb(y), ++ de[x];
	}
	For(i, 1, n) de[i] = qpow(de[i], Mod - 2);
	scanf("%s", a + 1), lena = strlen(a + 1);
	scanf("%s", b + 1), lenb = strlen(b + 1);
	For(i, 0, lena - 1) For(j, 0, 25)
	{
		if (a[i + 1] - 'a' == j) nxt[i][j] = i + 1;
		else Forr(k, i - 1, 0) if (a[k + 1] - 'a' == j)
		{
			int flag = 1; 
			For(t, 0, k - 1) if (a[k - t] != a[i - t]) { flag = 0; break; }
			if (flag) { nxt[i][j] = k + 1; break; }
		}
	}
	For(i, 0, lenb - 1) For(j, 0, 25) suf[i][j] = i + (b[i + 1] - 'a' == j);
	int cnt = 0;
	For(i, 1, n) For(j, 0, lena - 1) id[i][j] = ++ cnt;
	Forr(k, lenb - 1, 0) 
	{
		For(i, 1, n) For(j, 0, lena - 1) 
		{
			int now = id[i][j];
			For(to, 0, 25) for (auto v : G[i][to])
			{
				if (nxt[j][to] == lena || suf[k][to] > k)
					(A[now][cnt + 1] += 1ll * de[i] * dp[v][nxt[j][to]][suf[k][to]] % Mod) %= Mod;
				else 
					(A[now][id[v][nxt[j][to]]] += de[i]) %= Mod;
			}
			-- A[now][now], ++ A[now][cnt + 1];
		}
		Gauss(cnt);
		For(i, 1, n) For(j, 0, lena - 1) dp[i][j][k] = vis[id[i][j]];
	}
	printf("%d\n", (dp[1][0][0] + Mod) % Mod);

	return 0;
}

```

# cal

![](/home/lunch/Downloads/未命名_meitu_1.jpg)

Expected Score：30 Points

Really Score：30 Points

考试的时候没有花足够的时间，所以只写了前 3 个 Subtask，实际上如果考试多花一点时间在这里的话分又会多一些，最主要有了 WC 的经验看到这种题没有惊慌失措了．

## Subtask 1：

> 输入一个数 $a$ ，计算 $a^{100000} \rm mod \ 10000121$．

直接调用题目中的 $\rm pow$ 运算即可．

```cpp
input 1
pow 2 A[1] 100000
output A[2]
```

 ## Subtask 2：

> 输入一个长为 $[1,30000]​$ 的数列，倒序输出．

用 $\rm label$ 操作和 $\rm if$ 操作可以写出 $\rm do\ while $ 循环，用一个指针不断前移就好了．

```cpp
input 0

label in
add 40000 A[40000] 1
input A[40000]
if A[40000] A[0] out
if A[50000] 0 in

label out
output A[A[40000]]
add 40000 A[40000] 10000120
if A[40000] 0 end
if A[50000] 0 out

label end
```

## Subtask 3：

> 给你一个长为 $[1,20000]$ 的数列，每次询问区间乘积．

因为模数是质数，直接预处理前缀积，区间询问乘上逆元就好了．

```cpp
input 30001
input 30002

add 30003 A[30003] 1
mul 0 1 1

label in
add 999999 A[999999] 1
input A[999999]
mul 30003 A[30003] A[A[999999]]
mul A[999999] A[30003] 1
if A[999999] A[30001] out
if A[50000] 0 in

label out
add 30002 A[30002] 10000120
input 45678
input 56789
add 45678 A[45678] 10000120
pow 67890 A[A[45678]] 10000119
mul 67890 A[67890] A[A[56789]]
output A[67890]
if A[30002] 0 end
if A[88888] 0 out

label end
```

## Subtask 4：

> 输入一个数 $a$，判断这个数是否为偶数．

判断 $\rm (-1)^a$ 等于 $-1$ 还是 $1$ 即可．

```cpp
input 1
pow 2 10000120 A[1]
if A[2] 1 yes
if A[2] 10000120 no
label yes
output 1
if A[23333] 0 end
label no
output 0
label end
```

## Subtask 5：

> 输入一个数 $a$ ，判断这个数是不是 $3$ 的倍数．

因为 $3$ 是这个模数的一个原根，所以判断 $3^a=27^{a\times3^{-1}}$ 是否成立即可．

```cpp
input 1
pow 2 3 10000119
pow 4 3 A[1]
mul 1 A[1] A[2]
pow 5 27 A[1]
if A[4] A[5] yes
output 0
if A[233] 0 end
label yes
output 1
label end
```

## Subtask 6：

> 输入两个数 $a, b$ ，输出 $a + b$ ．

利用 $a + b=a\times(1+b\times a^{-1})$

```cpp
input 1
input 2
pow 3 A[2] 10000119
mul 1 A[3] A[1]
add 1 A[1] 1
mul 1 A[1] A[2]
output A[1]
```

## Subtask 7：

> 给你一个长为 $n$ 的数列 $a$ ，求 $\sum\limits_{i = 1}^na_i$．

用上一个题的方法即可．

```cpp
input 99999

add 100000 A[100000] 1
input A[100000]
if A[99999] 1 out

label while
add 100000 A[100000] 1
input A[100000]
add 998244 A[100000] 10000120
pow 998245 A[A[998244]] 10000119
mul A[100000] A[998245] A[A[100000]]
add A[100000] A[A[100000]] 1
mul A[100000] A[A[100000]] A[A[998244]]

if A[100000] A[99999] out
if A[111111] 0 while

label out
output A[A[99999]]
```

## Subtask 8：

> 输入两个数 $a,b$ ，计算 $\rm gcd(a,b)$ ．

用除了扩欧的另一种算法，暂时不会．

## Subtask 9：

> 判断一个值域在 $[1,2000]$ 内的整数是否为质数．

打表即可，暂时没写．

## Subtask 10：

> 提交一个至少有一个常数的代码，依序输出代码中所有的常数加一．

可以发现可以只用 $1$，可以先让 $\rm A[1]=1+1$，那么可以用 $\rm A[A[1]]$来做循环变量，那么只要输出若干次 $\rm A[1]$

用一个循环两次的循环就好了．

```cpp
add 1 1 1
label while
output A[1]
output A[1]
output A[1]
output A[1]
output A[1]
output A[1]
output A[1]
output A[1]
output A[1]
output A[1]
if A[A[1]] 1 out
add A[1] A[A[1]] 1
if A[A[1]] 1 while
label out
```

